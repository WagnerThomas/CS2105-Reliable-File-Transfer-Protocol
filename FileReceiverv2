import java.io.*;
import java.net.*;
import java.nio.ByteBuffer;
import java.util.zip.CRC32;

public class FileReceiver  {
	
	public static void main(String[] args) throws Exception {
		// Input validation
		if (args.length != 1) {
			System.err.println("Usage: FileReceiver <port>");
			System.exit(-1);
		}
		int port = Integer.parseInt(args[0]);
		DatagramSocket sk = new DatagramSocket(port);
		
		// Receive destination filename from FileSender
    	String destFileName = rcvDestFileName(sk);
    	System.out.println(destFileName);
    	//reliableReceiver(destFileName, sk);
    	newReliable(destFileName, sk);
	}
	
	public static String rcvDestFileName(DatagramSocket sk) throws Exception {
		
		byte[] data = new byte[1500];
		DatagramPacket pkt = new DatagramPacket(data, data.length);
		ByteBuffer b = ByteBuffer.wrap(data);
		CRC32 crc = new CRC32();
		// int i = 1; // keeps track of sequence number of packet we are expecting
		
		while(true)
		{
			pkt.setLength(data.length);
			sk.receive(pkt);
			if (pkt.getLength() < 12)
			{
				System.out.println("Pkt too short");
				continue;
			}
			b.rewind();
			long chksum = b.getLong();
			int seq_num = b.getInt();

			crc.reset();
			crc.update(data, 12, pkt.getLength()-12);
			
			if (crc.getValue() != chksum) // if checksum or sequence number is incorrect
			{
				System.out.println(crc.getValue() + " versus " + chksum);
				System.out.println("Packet corrupt");
			}
			else
			{
				String rcv = new String(data, 12, data.length-12);
				DatagramPacket ack = new DatagramPacket(new byte[1], 0, 1, pkt.getSocketAddress());
				sk.send(ack);
				// i++; // increment next sequence number of packet to expect
				return rcv;
			}
		}
	}
	
public static void newReliable(String filename, DatagramSocket sk) throws Exception {
		
		byte[] data = new byte[1500];
		DatagramPacket pkt = new DatagramPacket(data, data.length);
		ByteBuffer b = ByteBuffer.wrap(data);
		CRC32 crc = new CRC32();
		// int i = 1; // keeps track of sequence number of packet we are expecting
		long chksum;
		int seq_num;
		
		while(true)
		{
			pkt.setLength(data.length);
			sk.receive(pkt);
			if (pkt.getLength() < 12)
			{
				System.out.println("Pkt too short");
				continue;
			}
			b.rewind();
			chksum = b.getLong();
			seq_num = b.getInt();

			crc.reset();
			crc.update(data, 12, pkt.getLength()-12);
			
			if (crc.getValue() != chksum) // if checksum or sequence number is incorrect
			{
				System.out.println(crc.getValue() + " versus " + chksum);
				System.out.println("Packet corrupt");
			}
			else
			{
				System.out.println("Not corrupt");
				DatagramPacket ack = new DatagramPacket(new byte[1], 0, 1, pkt.getSocketAddress());
				sk.send(ack);
				// i++; // increment next sequence number of packet to expect
			}
		}
	}
	
	public static void reliableReceiver(String filename, DatagramSocket sk) throws IOException {
		File dest = new File(filename);
		
		FileOutputStream fos = null;
		BufferedOutputStream bos = null;
		
		try {
			fos = new FileOutputStream(dest);
			bos = new BufferedOutputStream(fos);
		}
		catch (FileNotFoundException e) {
			System.out.println("File not found!");
		}
		
		int seq_num;
		CRC32 crc = new CRC32();
		byte[] data = new byte[20];
		DatagramPacket pkt = new DatagramPacket(data, data.length);
		ByteBuffer bb = ByteBuffer.wrap(data);
		
		while(true)
		{
			pkt.setLength(data.length);
			sk.receive(pkt);
			if (pkt.getLength() < 8)
			{
				System.out.println("Pkt too short");
				continue;
			}
			bb.rewind();
			long chksum = bb.getLong();
			crc.reset();
			System.out.println("Chksum: " + chksum);
			System.out.println("crc.getValue(): " + crc.getValue());
			crc.update(data, 12, pkt.getLength()-12);
			// Debug output
			// System.out.println("Received CRC:" + crc.getValue() + " Data:" + bytesToHex(data, pkt.getLength()));
			if (crc.getValue() != chksum)
			{
				System.out.println(crc.getValue() + " versus " + chksum);
				System.out.println("Pkt corrupt");
			}
			else
			{
				seq_num = 0; // for debugging
				seq_num = bb.getInt();
				System.out.println("Pkt " + seq_num + "received");
				bos.write(bb.get());
				
				// Send ACK
				DatagramPacket ack = new DatagramPacket(new byte[0], 0, 0, pkt.getSocketAddress());
				sk.send(ack);
			}	
		}
	}
	
	final protected static char[] hexArray = "0123456789ABCDEF".toCharArray();
	public static String bytesToHex(byte[] bytes, int len) {
	    char[] hexChars = new char[len * 2];
	    for ( int j = 0; j < len; j++ ) {
	        int v = bytes[j] & 0xFF;
	        hexChars[j * 2] = hexArray[v >>> 4];
	        hexChars[j * 2 + 1] = hexArray[v & 0x0F];
	    }
	    return new String(hexChars);
	}
}
